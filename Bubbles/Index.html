<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="../js/three.js"></script>
		<script>
			var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
            

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
            
            var stride = 16;
            var geometry = new THREE.CircleBufferGeometry( 5, stride);
            var geometry1 = geometry.clone();
            var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
            material.wireframe=true;
            var circle = new THREE.Mesh( geometry, material );
            scene.add( circle );

			camera.position.z = 10;

            // var posArray=circle.
            console.log(circle.geometry.attributes);
            var posArray = circle.geometry.attributes.position.array;

            var springs=[];

            var centerVert = new THREE.Vector3(posArray[0],posArray[1],posArray[2]);
            for(var i=1; i<circle.geometry.attributes.position.count-1; i++) {
                var inx = i*3;
                var currentVert = new THREE.Vector3(posArray[inx],posArray[inx+1],posArray[inx+2]);

                //First spring
                var toCenter={};
                {
                    var vector = centerVert.clone().sub(currentVert);
                    var length = vector.length();
                    toCenter.vector = vector.normalize();
                    toCenter.restLength = length;
                }


                //Second spring
                var toPrevious={};
                {
                    var prevTargetInx;
                    if(i==1) prevTargetInx = stride;
                    else prevTargetInx= inx-1;

                    var otherVert = new THREE.Vector3(posArray[prevTargetInx],posArray[prevTargetInx+1],posArray[prevTargetInx+2]);

                    var vector = otherVert.clone().sub(currentVert);
                    var length = vector.length();
                    toPrevious.vector = vector.normalize();
                    toPrevious.restLength = length;
                }

                //Third spring
                var toNext={};
                {
                    var nextTargetInx;
                    if(i==stride) nextTargetInx = 1;
                    else nextTargetInx= inx+1;

                    var otherVert = new THREE.Vector3(posArray[nextTargetInx],posArray[nextTargetInx+1],posArray[nextTargetInx+2]);

                    var vector = otherVert.clone().sub(currentVert);
                    var length = vector.length();
                    toNext.vector = vector.normalize();
                    toNext.restLength = length;
                }
                
                springs[i] = {
                    toCenter: toCenter,
                    toPrevious: toPrevious,
                    toNext: toNext,
                };
            }

			var animate = function () {
				requestAnimationFrame( animate );
                array = circle.geometry.attributes.position.array;
                for(var i=1; i<circle.geometry.attributes.position.count-1; i++) {
                    var inx = i*3;
                    var currentPos = new THREE.Vector2(array[inx],array[inx+1]);
                    var displacement = new THREE.Vector2(0,0);

                    //Resolve spring to center
                    var neighbourInx = 0;
                    var neighbourPos = new THREE.Vector2(array[neighbourInx], array[neighbourInx+1]);
                    var springVector = neighbourPos.clone().sub(currentPos);
                    var length = springVector.length();
                    var undeformedLength = springs[i].toCenter.restLength;
                    var forceScaler = (length - undeformedLength) / undeformedLength;
                    var forceVector = springVector.clone().multiplyScalar(forceScaler * 0.01);
                    displacement.add(forceVector);

                    //Resolve spring to previous
                    var prevTargetInx;
                    if(i==1) prevTargetInx = stride;
                    else prevTargetInx= inx-1;
                    var neighbourPos = new THREE.Vector2(array[prevTargetInx], array[prevTargetInx+1]);
                    var springVector = neighbourPos.clone().sub(currentPos);
                    var length = springVector.length();
                    var undeformedLength = springs[i].toPrevious.restLength;
                    var forceScaler = (length - undeformedLength) / undeformedLength;
                    var forceVector = springVector.clone().multiplyScalar(forceScaler * 0.01);
                    displacement.add(forceVector);

                    //Resolve spring to previous
                    var nextTargetInx;
                    if(i==stride) nextTargetInx = 1;
                    else nextTargetInx= inx+1;
                    var neighbourPos = new THREE.Vector2(array[nextTargetInx], array[nextTargetInx+1]);
                    var springVector = neighbourPos.clone().sub(currentPos);
                    var length = springVector.length();
                    var undeformedLength = springs[i].toNext.restLength;
                    var forceScaler = (length - undeformedLength) / undeformedLength;
                    var forceVector = springVector.clone().multiplyScalar(forceScaler * 0.01);
                    displacement.add(forceVector);

                    var newPos = currentPos.clone().add(displacement);
                    // if(i==1) console.log(newPos);
                    geometry1.attributes.position.array[inx] = newPos.x;
                    geometry1.attributes.position.array[inx+1] = newPos.y;              
                }

                geometry1.attributes.position.array[(stride+1)*3 ] = geometry1.attributes.position.array[3];
                geometry1.attributes.position.array[(stride+1)*3 +1] = geometry1.attributes.position.array[4];
                
                circle.geometry = geometry1.clone();
                circle.geometry.needsUpdate=true;

				renderer.render( scene, camera );
			};

            document.onmousedown = function() {
                posArray = circle.geometry.attributes.position.array;
                var inx = 1*3;
                posArray[inx] *= 0.7;
                posArray[inx+1] *= 0.7;
            }

			animate();
		</script>
	</body>
</html>